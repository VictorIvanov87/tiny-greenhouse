# TG-013 — Dashboard charts from `/api/telemetry` (Recharts mini-graphs)

**Goal**  
Enhance the Dashboard with compact time-series charts for temperature, humidity, and soil moisture using **Recharts**. Keep the UI consistent with Flowbite (cards, spacing) and reuse the existing `getTelemetry()` API. Minimal deps: add only `recharts`.

> Follow `frontend/AGENTS.md` (Flowbite-first UI, full-height layout, responsive). Keep diffs small and focused on the Dashboard + a tiny shared chart component.

---

## Dependencies
Install in `frontend/`:
```bash
npm i recharts
```
_No other runtime libraries._

---

## Data & Query
Reuse `getTelemetry({ limit, from?, to?, sensor? })` from `src/features/telemetry/api.ts`.  
For now, fetch **the latest 200 samples** and aggregate client-side (simple rolling or bucket-by-minute).

**TelemetrySample**
```ts
type TelemetrySample = {
  timestamp: string;       // ISO
  temperature: number;
  humidity: number;
  soilMoisture: number;
  lightHours?: number;
  sensor?: string;
}
```

---

## Scope (frontend)
- Add a small **ChartCard** component to wrap a Recharts graph inside a Flowbite `Card` with a title and footer.
- Update **DashboardPage.tsx** to:
  - Fetch the last N samples (e.g., `limit=200`).
  - Render three mini-graphs:
    1) **Temperature (°C)** — line or area
    2) **Humidity (%)** — line or area
    3) **Soil moisture (%)** — line or area
  - Provide a simple **time window switcher** (buttons): `1h / 6h / 24h`. Filter the in-memory dataset by timestamp.
  - Keep existing KPIs/table from TG-009.
- Handle loading/error states as before; charts should not crash on empty data (show "No data").

---

## File changes
```
src/
  shared/ui/
    ChartCard.tsx                 # NEW — Flowbite Card + Recharts wrapper
  features/dashboard/
    DashboardPage.tsx             # UPDATE — add charts + time window
  features/telemetry/
    transforms.ts                 # NEW — helpers: parse, filterByWindow, bucketByMinute (optional)
```

### `src/shared/ui/ChartCard.tsx` (sketch)
```tsx
import { Card } from 'flowbite-react';
import { ReactNode } from 'react';

export function ChartCard({ title, children, footer }: { title: string; children: ReactNode; footer?: ReactNode }) {
  return (
    <Card>
      <div className="flex items-center justify-between mb-2">
        <div className="text-sm text-gray-500">{title}</div>
        {footer}
      </div>
      <div className="h-36 md:h-40">{children}</div>
    </Card>
  );
}
```

### `src/features/telemetry/transforms.ts` (sketch)
```ts
export type WindowKey = '1h' | '6h' | '24h';

export function parseTs(iso: string): number {
  return new Date(iso).getTime();
}

export function filterByWindow<T extends { timestamp: string }>(items: T[], win: WindowKey): T[] {
  if (!items.length) return items;
  const now = parseTs(items[items.length - 1].timestamp); // assume sorted asc by backend; if not, sort first
  const ms = win === '1h' ? 3600e3 : win === '6h' ? 6 * 3600e3 : 24 * 3600e3;
  const from = now - ms;
  return items.filter((i) => parseTs(i.timestamp) >= from);
}

// optional bucket if points are too dense
export function bucketByMinute<T extends { timestamp: string }>(items: T[], pick: (x: T) => number) {
  const m = new Map<number, { t: number; v: number }>();
  for (const it of items) {
    const t = new Date(it.timestamp);
    t.setSeconds(0, 0);
    const key = t.getTime();
    const v = pick(it);
    m.set(key, { t: key, v }); // last value per minute; could average if needed
  }
  return Array.from(m.values()).sort((a, b) => a.t - b.t).map(({ t, v }) => ({ t, v }));
}
```

### `src/features/dashboard/DashboardPage.tsx` (chart fragment sketch)
```tsx
import { useEffect, useMemo, useState } from 'react';
import { Spinner, Alert, Button, ButtonGroup } from 'flowbite-react';
import { LineChart, Line, AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
import { ChartCard } from '@/shared/ui/ChartCard';
import { getTelemetry, TelemetrySample } from '@/features/telemetry/api';
import { filterByWindow, bucketByMinute, WindowKey } from '@/features/telemetry/transforms';

export default function DashboardPage() {
  const [items, setItems] = useState<TelemetrySample[] | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [win, setWin] = useState<WindowKey>('6h');

  useEffect(() => {
    let alive = true;
    setLoading(true);
    getTelemetry({ limit: 200 })
      .then((res) => { if (alive) setItems(res.items); })
      .catch((e) => { if (alive) setError(e.message || 'Failed to load'); })
      .finally(() => { if (alive) setLoading(false); });
    return () => { alive = false; };
  }, []);

  const data = useMemo(() => {
    const src = items ? filterByWindow(items, win) : [];
    const temp = bucketByMinute(src, i => i.temperature).map(x => ({ t: x.t, value: x.v }));
    const hum  = bucketByMinute(src, i => i.humidity).map(x => ({ t: x.t, value: x.v }));
    const soil = bucketByMinute(src, i => i.soilMoisture).map(x => ({ t: x.t, value: x.v }));
    return { temp, hum, soil };
  }, [items, win]);

  if (loading) return <div className="min-h-[60vh] flex items-center justify-center"><Spinner size="xl" /></div>;
  if (error) return <div className="p-4"><Alert color="failure">{error}</Alert></div>;

  function TimeSwitch() {
    return (
      <ButtonGroup>
        {(['1h','6h','24h'] as WindowKey[]).map(k => (
          <Button key={k} size="xs" color={k === win ? 'success' : 'light'} onClick={() => setWin(k)}>
            {k}
          </Button>
        ))}
      </ButtonGroup>
    );
  }

  const fmt = (t: number) => new Date(t).toLocaleTimeString();

  return (
    <div className="p-4 space-y-4">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <ChartCard title="Temperature (°C)" footer={<TimeSwitch />}>
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data.temp}>
              <XAxis dataKey="t" tickFormatter={fmt} hide />
              <YAxis hide />
              <Tooltip labelFormatter={(v) => new Date(v as number).toLocaleString()} />
              <Area type="monotone" dataKey="value" fillOpacity={0.2} />
            </AreaChart>
          </ResponsiveContainer>
        </ChartCard>

        <ChartCard title="Humidity (%)" footer={<TimeSwitch />}>
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data.hum}>
              <XAxis dataKey="t" tickFormatter={fmt} hide />
              <YAxis hide />
              <Tooltip labelFormatter={(v) => new Date(v as number).toLocaleString()} />
              <Area type="monotone" dataKey="value" fillOpacity={0.2} />
            </AreaChart>
          </ResponsiveContainer>
        </ChartCard>

        <ChartCard title="Soil moisture (%)" footer={<TimeSwitch />}>
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data.soil}>
              <XAxis dataKey="t" tickFormatter={fmt} hide />
              <YAxis hide />
              <Tooltip labelFormatter={(v) => new Date(v as number).toLocaleString()} />
              <Area type="monotone" dataKey="value" fillOpacity={0.2} />
            </AreaChart>
          </ResponsiveContainer>
        </ChartCard>
      </div>

      {/* Keep your existing KPI cards and telemetry table below */}
    </div>
  );
}
```

---

## UX notes
- Charts must be responsive: wrap with `ResponsiveContainer` and place inside a fixed-height container (`h-36 md:h-40`).
- Keep the same **TimeSwitch** for all three charts (DRY: optional extract to a small component).
- Tooltips should show a human date/time; axes can be hidden for compactness.
- Gracefully handle empty arrays: render a small "No data" text inside the Card.

---

## Acceptance
- `npm i recharts` added to `frontend` and imported only where needed.
- Dashboard fetches the latest 200 telemetry samples and renders three compact charts.
- Time window buttons (1h/6h/24h) filter the in-memory dataset without refetching.
- Charts are responsive and do not cause horizontal scroll at sm/md/lg breakpoints.
- On network error, an Alert is shown; on empty data, charts show “No data”.

---

## Notes for agents
- Keep diffs constrained to `shared/ui/ChartCard.tsx`, `features/telemetry/transforms.ts`, and `features/dashboard/DashboardPage.tsx`.
- Do not introduce new runtime deps beyond `recharts`. If type helpers are needed, add small local utilities.
- Respect the envelope contract (`{ ok, data }`) and avoid touching backend code.
