# TG-012 — Timelapse gallery wired to `/api/timelapse`

**Goal**  
Build a Timelapse screen that fetches frames from the backend and renders an interactive gallery + lightweight player (Play/Pause, speed). No new runtime deps; use Flowbite + Tailwind only.

> Follow `frontend/AGENTS.md` (Flowbite-first UI, full-height layout, responsive).

---

## Backend contract (already provided by TG-007)
`GET /api/timelapse` → `{ ok: true, data: { items: TimelapseFrame[], total: number } }`

```ts
// Mirror of backend types
export interface TimelapseFrame {
  id: string;
  greenhouseId: string;
  timestamp: string; // ISO
  url: string;       // image URL
}
export interface TimelapseList {
  items: TimelapseFrame[];
  total: number;
}
```

Query params supported by the mock route (keep optional on the client):
- `limit?: number` (default 50)
- `from?: string` (ISO)
- `to?: string` (ISO)

---

## Scope (frontend)
- Add `src/features/timelapse/api.ts` with:
  - `getTimelapse({ limit = 50, from?, to? }): Promise<TimelapseList>` → calls `/api/timelapse`.
- Implement `src/features/timelapse/TimelapsePage.tsx`:
  - Fetch frames on mount (`limit=50`); Spinner while loading; Alert on error; empty state if no frames.
  - Grid of thumbnails (responsive) using Flowbite `Card` or bare `img` + Tailwind.
  - Clicking a thumbnail opens a **Modal** with a simple player:
    - Centered large image
    - Controls: **Play/Pause**, **Speed** (0.5× / 1× / 2×), **Prev/Next**, **Close**
    - Timestamp overlay (bottom-right, semi-transparent)
  - Optional filters above the grid:
    - Date range (`from`/`to` as ISO text inputs for now)
    - Limit select (25/50/100)
    - **Refresh** button
- Wire route `/timelapse` and add it to Sidebar.

### Recommended layout
- Page container: `p-4 space-y-4`
- Filter bar: `Card` with inline controls
- Grid: CSS grid with `grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3`
- Modal image: `max-h-[70vh] w-auto object-contain`

---

## File changes
```
src/
  features/
    timelapse/
      api.ts                 # NEW
      TimelapsePage.tsx      # NEW
  app/routes.tsx             # UPDATE — add route
  app/App.tsx (Sidebar)      # UPDATE — add nav item if missing
```

### `src/features/timelapse/api.ts` (sketch)
```ts
import { api } from '@/shared/hooks/useApi';

export type TimelapseFrame = {
  id: string;
  greenhouseId: string;
  timestamp: string;
  url: string;
};
export type TimelapseList = { items: TimelapseFrame[]; total: number };

export async function getTimelapse(params: { limit?: number; from?: string; to?: string } = {}): Promise<TimelapseList> {
  const { data } = await api.get('/timelapse', { params });
  if (!data?.ok) throw new Error('Failed to load timelapse');
  return data.data as TimelapseList;
}
```

### `src/features/timelapse/TimelapsePage.tsx` (sketch)
```tsx
import { useEffect, useMemo, useRef, useState } from 'react';
import { Card, Spinner, Alert, Button, Modal, Label, TextInput, Select } from 'flowbite-react';
import { getTimelapse, TimelapseFrame } from './api';

export default function TimelapsePage() {
  const [items, setItems] = useState<TimelapseFrame[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [open, setOpen] = useState(false);
  const [index, setIndex] = useState(0);
  const [speed, setSpeed] = useState(1); // frames per step
  const timer = useRef<number | null>(null);
  const [form, setForm] = useState<{ limit: number; from?: string; to?: string }>({ limit: 50 });

  async function load() {
    setLoading(true);
    setError(null);
    try {
      const res = await getTimelapse(form);
      setItems(res.items);
    } catch (e: any) {
      setError(e.message || 'Failed to load timelapse');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { load(); /* eslint-disable-next-line react-hooks/exhaustive-deps */ }, []);

  function openAt(i: number) { setIndex(i); setOpen(true); }
  function close() { setOpen(false); stop(); }
  function prev() { setIndex(i => (i - 1 + items.length) % items.length); }
  function next() { setIndex(i => (i + 1) % items.length); }
  function play() {
    if (timer.current) return;
    timer.current = window.setInterval(() => { setIndex(i => (i + 1) % items.length); }, 800 / speed);
  }
  function stop() {
    if (timer.current) { window.clearInterval(timer.current); timer.current = null; }
  }

  if (loading) return <div className="min-h-[60vh] flex items-center justify-center"><Spinner size="xl" /></div>;
  if (error) return <div className="p-4"><Alert color="failure">{error}</Alert></div>;
  if (!items.length) return <div className="p-4"><Alert color="info">No frames yet.</Alert></div>;

  return (
    <div className="p-4 space-y-4">
      <Card>
        <div className="grid gap-3 md:grid-cols-4">
          <div className="md:col-span-1">
            <Label htmlFor="limit" value="Limit" />
            <Select id="limit" value={form.limit} onChange={(e) => setForm({ ...form, limit: Number(e.target.value) })}>
              <option value={25}>25</option>
              <option value={50}>50</option>
              <option value={100}>100</option>
            </Select>
          </div>
          <div>
            <Label htmlFor="from" value="From (ISO)" />
            <TextInput id="from" value={form.from || ''} onChange={(e) => setForm({ ...form, from: e.target.value || undefined })} />
          </div>
          <div>
            <Label htmlFor="to" value="To (ISO)" />
            <TextInput id="to" value={form.to || ''} onChange={(e) => setForm({ ...form, to: e.target.value || undefined })} />
          </div>
          <div className="flex items-end">
            <Button onClick={load}>Refresh</Button>
          </div>
        </div>
      </Card>

      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
        {items.map((f, i) => (
          <button key={f.id} className="group relative" onClick={() => openAt(i)}>
            <img src={f.url} alt={new Date(f.timestamp).toLocaleString()} className="w-full h-28 object-cover rounded-lg shadow" />
            <div className="absolute bottom-1 right-1 rounded px-1.5 py-0.5 text-xs bg-black/60 text-white opacity-90">
              {new Date(f.timestamp).toLocaleDateString()}
            </div>
          </button>
        ))}
      </div>

      <Modal show={open} onClose={close} size="4xl">
        <Modal.Header>Timelapse</Modal.Header>
        <Modal.Body>
          <div className="flex flex-col items-center gap-3">
            <img src={items[index].url} alt={new Date(items[index].timestamp).toLocaleString()} className="max-h-[70vh] w-auto object-contain rounded" />
            <div className="text-sm text-gray-600">{new Date(items[index].timestamp).toLocaleString()}</div>
            <div className="flex items-center gap-2">
              <Button color="light" onClick={prev}>Prev</Button>
              <Button onClick={play}>Play</Button>
              <Button color="warning" onClick={stop}>Pause</Button>
              <Button color="light" onClick={next}>Next</Button>
              <Select value={speed} onChange={(e) => setSpeed(Number(e.target.value))}>
                <option value={0.5}>0.5×</option>
                <option value={1}>1×</option>
                <option value={2}>2×</option>
              </Select>
            </div>
          </div>
        </Modal.Body>
        <Modal.Footer>
          <Button color="light" onClick={close}>Close</Button>
        </Modal.Footer>
      </Modal>
    </div>
  );
}
```

---

## Acceptance
- Visiting `/timelapse` loads frames via GET (`limit=50` by default).
- Loading shows a Spinner; network errors show an Alert; empty state shows an info Alert.
- Thumbnails render in a responsive grid; clicking opens a Modal with a working player:
  - Play/Pause advances frames; Prev/Next work; speed changes interval.
  - Timestamp is visible.
- Filters (limit and optional from/to) re-fetch data when clicking **Refresh**.
- No new dependencies added.

---

## Notes for agents
- Keep diffs constrained to the `features/timelapse` folder + route/nav.
- Use Flowbite components; only Tailwind utilities for layout.
- Do not leak secrets; all requests go through the central Axios client.
