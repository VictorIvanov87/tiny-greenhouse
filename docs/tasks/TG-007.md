# TG-007 — Mock API endpoints (telemetry, timelapse, notifications, greenhouse)

**Goal**  
Expose realistic mock endpoints that the frontend can consume for `/dashboard`, `/sensor-data`, `/settings`, and `/notifications`. Data is read from JSON files in `backend/data/mock/*` and validated with Zod. No database or auth yet.

> Follow `backend/AGENTS.md`. Keep changes inside `backend/` only.

---

## Scope
Implement these endpoints with mock data + Zod validation:

- `GET /api/telemetry?from&to&limit&sensor`
  - Returns a paged list of telemetry samples (timestamp, temperature, humidity, soilMoisture, lightHours?).
  - Filters: by `from`/`to` (ISO datetime), by `sensor` (optional string), and `limit` (1–100; default 25).
- `GET /api/timelapse?limit`
  - Returns an array of frames `{ url, timestamp }` (placeholder URLs or base64 data URLs for now).
- `GET /api/greenhouses/current`
  - Returns the current greenhouse config `{ id, name, method: 'soil'|'nft'|'dwc', plantType, language, timelapse: { enabled, hour } }`.
- `GET /api/notifications`
  - Returns notification preferences `{ email: boolean, push: boolean, thresholds: { soilMoistureLow: number, tempHigh: number } }`.
- `PUT /api/notifications`
  - Accepts the same shape as above and persists it **in-memory only** for now (still read defaults from JSON).

> Keep handlers small: parse query/path with Zod; map to mock data; return the common `{ ok, data }` envelope.

---

## Out of Scope
- Persistence (no writes to disk); PUT only updates in-memory state.
- Auth/Firebase (added later in TG-008).
- Realtime sockets or ingestion endpoints.

---

## Dependencies
Already installed in TG-006. No new runtime deps.

---

## Files to create/modify

```
backend/
  src/
    routes/
      telemetry.ts
      timelapse.ts
      notifications.ts
      greenhouse.ts
    lib/
      schemas.ts        # extend with new Zod schemas
      respond.ts        # already present
      file.ts           # NEW: tiny helper to read JSON mock files
    app.ts              # register new routes
  data/mock/
    telemetry.json
    timelapse.json
    notifications.json
    greenhouse.json
```

---

## Zod Schemas (add to `lib/schemas.ts`)

```ts
import { z } from 'zod';

export const ISODate = z.string().datetime();

export const TelemetrySample = z.object({
  timestamp: ISODate,
  temperature: z.number(),
  humidity: z.number(),
  soilMoisture: z.number(),
  lightHours: z.number().optional(),
  sensor: z.string().optional()         // optional label/id
});
export type TelemetrySample = z.infer<typeof TelemetrySample>;

export const TelemetryList = z.object({
  items: z.array(TelemetrySample),
  total: z.number().int().nonnegative()
});
export type TelemetryList = z.infer<typeof TelemetryList>;

export const TimelapseFrame = z.object({
  timestamp: ISODate,
  url: z.string()
});
export const TimelapseList = z.object({
  items: z.array(TimelapseFrame),
  total: z.number().int().nonnegative()
});

export const GreenhouseConfig = z.object({
  id: z.string(),
  name: z.string(),
  method: z.enum(['soil', 'nft', 'dwc']),
  plantType: z.string(),
  language: z.enum(['bg', 'en']),
  timelapse: z.object({
    enabled: z.boolean(),
    hour: z.number().int().min(0).max(23)
  })
});

export const NotificationPrefs = z.object({
  email: z.boolean(),
  push: z.boolean(),
  thresholds: z.object({
    soilMoistureLow: z.number(),    // e.g., 25 (%)
    tempHigh: z.number()            // e.g., 32 (°C)
  })
});
```

---

## Helper for reading mock JSON (create `lib/file.ts`)

```ts
import { readFile } from 'node:fs/promises';
import { resolve } from 'node:path';

const root = resolve(process.cwd(), 'data', 'mock');

export async function readMock<T>(name: string): Promise<T> {
  const file = resolve(root, name);
  const buf = await readFile(file, 'utf8');
  return JSON.parse(buf) as T;
}
```

---

## Route recipes

### `routes/telemetry.ts`
```ts
import { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { TelemetryList, TelemetrySample } from '../lib/schemas';
import { ok } from '../lib/respond';
import { readMock } from '../lib/file';

const Query = z.object({
  from: z.string().datetime().optional(),
  to: z.string().datetime().optional(),
  sensor: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(100).default(25)
});

const telemetryRoutes: FastifyPluginAsync = async (app) => {
  app.get('/api/telemetry', {
    schema: { querystring: Query.strict(), response: { 200: TelemetryList } as any }
  }, async (req) => {
    const q = Query.parse(req.query);
    const raw = await readMock<TelemetrySample[]>('telemetry.json');
    const filtered = raw.filter(s => {
      const t = new Date(s.timestamp).getTime();
      const inFrom = !q.from || t >= new Date(q.from).getTime();
      const inTo = !q.to || t <= new Date(q.to).getTime();
      const bySensor = !q.sensor || s.sensor === q.sensor;
      return inFrom && inTo && bySensor;
    });
    return ok({ items: filtered.slice(0, q.limit), total: filtered.length });
  });
};

export default telemetryRoutes;
```

### `routes/timelapse.ts`
```ts
import { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { TimelapseList, TimelapseFrame } from '../lib/schemas';
import { ok } from '../lib/respond';
import { readMock } from '../lib/file';

const Query = z.object({
  limit: z.coerce.number().int().min(1).max(200).default(50)
});

const timelapseRoutes: FastifyPluginAsync = async (app) => {
  app.get('/api/timelapse', {
    schema: { querystring: Query.strict(), response: { 200: TimelapseList } as any }
  }, async (req) => {
    const q = Query.parse(req.query);
    const frames = await readMock<TimelapseFrame[]>('timelapse.json');
    return ok({ items: frames.slice(-q.limit), total: frames.length });
  });
};

export default timelapseRoutes;
```

### `routes/greenhouse.ts`
```ts
import { FastifyPluginAsync } from 'fastify';
import { GreenhouseConfig } from '../lib/schemas';
import { ok } from '../lib/respond';
import { readMock } from '../lib/file';

const greenhouseRoutes: FastifyPluginAsync = async (app) => {
  app.get('/api/greenhouses/current', {
    schema: { response: { 200: GreenhouseConfig } as any }
  }, async () => {
    const cfg = await readMock<any>('greenhouse.json');
    return ok(cfg);
  });
};

export default greenhouseRoutes;
```

### `routes/notifications.ts`
```ts
import { FastifyPluginAsync } from 'fastify';
import { NotificationPrefs } from '../lib/schemas';
import { ok } from '../lib/respond';
import { readMock } from '../lib/file';

let cache: any | null = null;

const notificationRoutes: FastifyPluginAsync = async (app) => {
  app.get('/api/notifications', {
    schema: { response: { 200: NotificationPrefs } as any }
  }, async () => {
    if (!cache) cache = await readMock('notifications.json');
    return ok(cache);
  });

  app.put('/api/notifications', {
    schema: { body: NotificationPrefs as any, response: { 200: NotificationPrefs } as any }
  }, async (req) => {
    cache = req.body;
    return ok(cache);
  });
};

export default notificationRoutes;
```

---

## Mock JSON (create under `backend/data/mock/`)

**telemetry.json** (at least 50 samples, ISO timestamps ascending; here is a small shape):  
```json
[
  { "timestamp": "2025-10-01T08:00:00.000Z", "temperature": 23.1, "humidity": 48.2, "soilMoisture": 31.5, "lightHours": 10.2, "sensor": "gh-1" },
  { "timestamp": "2025-10-01T09:00:00.000Z", "temperature": 23.6, "humidity": 47.8, "soilMoisture": 31.3, "lightHours": 10.9, "sensor": "gh-1" }
]
```

**timelapse.json**:  
```json
[
  { "timestamp": "2025-10-01T08:00:00.000Z", "url": "/images/timelapse/frame-0001.jpg" },
  { "timestamp": "2025-10-02T08:00:00.000Z", "url": "/images/timelapse/frame-0002.jpg" }
]
```

**greenhouse.json**:  
```json
{
  "id": "gh-1",
  "name": "Tiny Greenhouse #1",
  "method": "soil",
  "plantType": "basket-of-fire",
  "language": "en",
  "timelapse": { "enabled": true, "hour": 9 }
}
```

**notifications.json**:  
```json
{
  "email": true,
  "push": false,
  "thresholds": { "soilMoistureLow": 25, "tempHigh": 32 }
}
```

---

## Server wiring (update `src/app.ts`)
Register the routes after `health`:
```ts
app.register(import('./routes/telemetry').then(m => m.default));
app.register(import('./routes/timelapse').then(m => m.default));
app.register(import('./routes/notifications').then(m => m.default));
app.register(import('./routes/greenhouse').then(m => m.default));
```

---

## Smoke checks (must pass)
- `GET /api/telemetry?limit=10` returns 10 items and `total >= 10`.
- `GET /api/telemetry?from=<ISO>&to=<ISO>` respects time filter.
- `GET /api/timelapse?limit=2` returns the last 2 frames.
- `GET /api/greenhouses/current` returns the mock config.
- `GET /api/notifications` and `PUT /api/notifications` round-trip the in-memory state.
- All endpoints return the `{ ok, data }` envelope and pass Zod schemas.

---

## Notes for agents
- Keep diffs tight; do not reformat unrelated files.
- Prefer small, composable helpers (`lib/file.ts`).
- Use **Zod** for both inputs and responses; reject invalid data with proper 400.
