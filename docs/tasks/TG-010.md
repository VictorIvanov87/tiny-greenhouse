# TG-010 — Wire `/api/greenhouses/current` to Setup & Settings (GET + PUT)

**Goal**  
Load the current greenhouse configuration from the backend and allow editing/saving it from both **Setup** and **Settings** pages. Use the existing mock backend (`/api/greenhouses/current`) with auth preHandler (mock mode is fine).

> Follow `frontend/AGENTS.md` (Flowbite-first UI, Tailwind layout). No new runtime deps.

---

## Scope (frontend)
- Create a small API layer for greenhouse config:
  - `getCurrentGreenhouse()` → `GET /api/greenhouses/current`.
  - `updateCurrentGreenhouse(payload)` → `PUT /api/greenhouses/current`.
- Update **Setup** page to fetch config on mount, render a wizard-like form, and **save** via PUT. On success, redirect to `/dashboard`.
- Update **Settings** page to fetch config, render the same form (single screen), and **save** via PUT. On success, show a confirmation Alert.
- Handle loading/error states consistently (Spinner/Alert). Keep diffs small.

---

## Backend contract (already provided by TG-007/TG-008)
`GET /api/greenhouses/current` → `{ ok: true, data: GreenhouseConfig }`  
`PUT /api/greenhouses/current` (body: GreenhouseConfig) → `{ ok: true, data: GreenhouseConfig }`

```ts
// Types (mirror backend Zod)
export type GreenhouseMethod = 'soil' | 'nft' | 'dwc';
export type Language = 'bg' | 'en';

export interface GreenhouseConfig {
  id: string;
  name: string;
  method: GreenhouseMethod;
  plantType: string;
  language: Language;
  timelapse: { enabled: boolean; hour: number }; // 0..23
}
```

---

## Files to add/change (frontend)
```
src/
  features/
    greenhouse/
      api.ts           # NEW — HTTP helpers for GET/PUT
      types.ts         # NEW — shared types for GreenhouseConfig
      form/            # NEW (optional) — small presentational inputs (not required)
  features/setup/
    SetupPage.tsx      # UPDATE — load form, save, redirect
  features/settings/
    SettingsPage.tsx   # UPDATE — load form, save, confirmation
  shared/hooks/
    useApi.ts          # ensure baseURL '/api' and token attach (already present)
```

### `src/features/greenhouse/types.ts`
```ts
export type GreenhouseMethod = 'soil' | 'nft' | 'dwc';
export type Language = 'bg' | 'en';

export interface GreenhouseConfig {
  id: string;
  name: string;
  method: GreenhouseMethod;
  plantType: string;
  language: Language;
  timelapse: { enabled: boolean; hour: number };
}
```

### `src/features/greenhouse/api.ts`
```ts
import { api } from '@/shared/hooks/useApi';
import type { GreenhouseConfig } from './types';

type Envelope<T> = { ok: true; data: T } | { ok: false; error: { code: string; message: string } };

export async function getCurrentGreenhouse(): Promise<GreenhouseConfig> {
  const { data } = await api.get<Envelope<GreenhouseConfig>>('/greenhouses/current');
  if (!('ok' in data) || !data.ok) throw new Error('Failed to load greenhouse config');
  return data.data;
}

export async function updateCurrentGreenhouse(payload: GreenhouseConfig): Promise<GreenhouseConfig> {
  const { data } = await api.put<Envelope<GreenhouseConfig>>('/greenhouses/current', payload);
  if (!('ok' in data) || !data.ok) throw new Error('Failed to update greenhouse config');
  return data.data;
}
```

### Form shape (both pages)
Use Flowbite components: `TextInput`, `Select`, `ToggleSwitch`, `Button`, `Card`, `Alert`, `Spinner`.

**Fields:**
- **Name** (`TextInput`)
- **Method** (`Select`: soil/nft/dwc)
- **Plant type** (`TextInput` for now; later can be a Select with presets)
- **Language** (`Select`: en/bg)
- **Timelapse Enabled** (`ToggleSwitch`)
- **Timelapse Hour** (`TextInput` type="number", min=0, max=23, disabled if not enabled)

### `src/features/settings/SettingsPage.tsx` (sketch)
```tsx
import { useEffect, useState } from 'react';
import { Card, Spinner, Alert, Button, Label, Select, TextInput, ToggleSwitch } from 'flowbite-react';
import { getCurrentGreenhouse, updateCurrentGreenhouse } from '@/features/greenhouse/api';
import type { GreenhouseConfig } from '@/features/greenhouse/types';

export default function SettingsPage() {
  const [cfg, setCfg] = useState<GreenhouseConfig | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [saved, setSaved] = useState(false);
  const [busy, setBusy] = useState(false);

  useEffect(() => {
    let mounted = true;
    getCurrentGreenhouse()
      .then((data) => { if (mounted) setCfg(data); })
      .catch((e) => setError(e.message || 'Failed to load'))
    return () => { mounted = false; }
  }, []);

  if (!cfg && !error) return <div className="min-h-[60vh] flex items-center justify-center"><Spinner size="xl" /></div>;
  if (error) return <div className="p-4"><Alert color="failure">{error}</Alert></div>;

  return (
    <div className="p-4">
      {saved && <div className="mb-4"><Alert color="success">Settings saved</Alert></div>}
      <Card className="max-w-2xl">
        <div className="grid gap-4">
          <div>
            <Label htmlFor="name" value="Greenhouse name" />
            <TextInput id="name" value={cfg!.name} onChange={(e) => setCfg({ ...cfg!, name: e.target.value })} />
          </div>

          <div>
            <Label htmlFor="method" value="Method" />
            <Select id="method" value={cfg!.method} onChange={(e) => setCfg({ ...cfg!, method: e.target.value as any })}>
              <option value="soil">Soil</option>
              <option value="nft">NFT</option>
              <option value="dwc">DWC</option>
            </Select>
          </div>

          <div>
            <Label htmlFor="plantType" value="Plant type" />
            <TextInput id="plantType" value={cfg!.plantType} onChange={(e) => setCfg({ ...cfg!, plantType: e.target.value })} />
          </div>

          <div>
            <Label htmlFor="language" value="Language" />
            <Select id="language" value={cfg!.language} onChange={(e) => setCfg({ ...cfg!, language: e.target.value as any })}>
              <option value="en">English</option>
              <option value="bg">Български</option>
            </Select>
          </div>

          <div className="flex items-center gap-4">
            <ToggleSwitch checked={cfg!.timelapse.enabled} label="Timelapse enabled" onChange={(v) => setCfg({ ...cfg!, timelapse: { ...cfg!.timelapse, enabled: v } })} />
            <div className="flex items-center gap-2">
              <Label htmlFor="tlHour" value="Hour" />
              <TextInput id="tlHour" type="number" min={0} max={23} disabled={!cfg!.timelapse.enabled}
                value={cfg!.timelapse.hour}
                onChange={(e) => setCfg({ ...cfg!, timelapse: { ...cfg!.timelapse, hour: Math.max(0, Math.min(23, Number(e.target.value)||0)) } })} />
            </div>
          </div>

          <div className="flex gap-3">
            <Button isProcessing={busy} onClick={async () => {
              try { setBusy(true); await updateCurrentGreenhouse(cfg!); setSaved(true); }
              catch (e: any) { setError(e.message || 'Save failed'); }
              finally { setBusy(false); }
            }}>Save</Button>
            <Button color="light" onClick={() => window.location.reload()}>Reset</Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
```

### `src/features/setup/SetupPage.tsx` (sketch)
- Same form as Settings, but after successful `updateCurrentGreenhouse`, **navigate to `/dashboard`**.
- Optional: if you already store a `hasSetup` flag, set it on success; otherwise rely on routing logic.

```tsx
// after save:
import { useNavigate } from 'react-router-dom';
// ...
await updateCurrentGreenhouse(cfg!);
navigate('/dashboard');
```

---

## UX/Validation notes
- Validate **Timelapse hour** ∈ 0..23; disable the input when timelapse is off.
- Keep form accessible: labels linked to inputs; keyboard-friendly.
- Mobile first: use `max-w-2xl` container, `space-y-*`, and avoid horizontal scroll.

---

## Acceptance
- Setup page loads current config, allows editing, and on Save performs `PUT /api/greenhouses/current` and redirects to `/dashboard`.
- Settings page loads current config, allows editing, and on Save performs `PUT /api/greenhouses/current` and shows a success Alert.
- Loading state shows a centered Spinner; error state shows an Alert with a meaningful message.
- All requests go through the existing Axios client (`/api` base URL, auth header if available).

---

## Notes for agents
- Keep diffs focused in `features/greenhouse`, `features/settings`, and `features/setup`.
- Reuse UI components; prefer Flowbite React (`TextInput`, `Select`, `ToggleSwitch`, `Button`, `Card`, `Alert`, `Spinner`).
- Do not introduce new dependencies. If a form helper is needed, implement a tiny local utility.
