# TG-014 — Sensor Data table (detailed view + filters/sorting)

**Goal**  
Build a dedicated **Sensor Data** screen showing telemetry as a detailed, filterable, and sortable table. Reuse the `/api/telemetry` endpoint. No new runtime deps.

> Follow `frontend/AGENTS.md` (Flowbite-first UI, full-height layout, responsive). Keep diffs tightly scoped to the new feature.

---

## Backend contract
Reuse `GET /api/telemetry` with query params:
- `limit?: number` (default 50)
- `from?: string` (ISO)
- `to?: string` (ISO)
- `sensor?: string` (optional; mock may ignore but keep param for future)

Response envelope: `{ ok: true, data: { items: TelemetrySample[], total: number } }`

```ts
export type TelemetrySample = {
  timestamp: string;       // ISO
  temperature: number;     // °C
  humidity: number;        // %
  soilMoisture: number;    // %
  lightHours?: number;     // optional
  sensor?: string;         // optional sensor id/name
};
```

---

## Scope (frontend)
- Add a new page `SensorDataPage.tsx` under `src/features/telemetry/`.
- Provide a filter bar:
  - **From** / **To** (ISO strings for now, `TextInput`).
  - **Limit** (`Select`: 25/50/100/200).
  - **Sensor** (`TextInput` plain string; optional).
  - **Apply** / **Reset** buttons.
- Render a **Flowbite Table** with columns:
  - Time (formatted local)
  - Temperature (°C)
  - Humidity (%)
  - Soil moisture (%)
  - Sensor (if present)
- Sorting controls on headers (client-side) for Time/Temp/Humidity/Soil:
  - Clicking a header toggles: asc → desc → none.
  - Sorting applies to the currently loaded items.
- Pagination (client-side) over the loaded items:
  - Page size: 25 by default (configurable via a small select: 25/50).
  - Prev/Next buttons; page indicator.
- Empty/Loading/Error states:
  - Spinner while fetching; Alert on error; Info Alert for empty result.
- Optional: **Export CSV** button for the current filtered + sorted page (client-side; build a blob and trigger download).

_No new dependencies._

---

## File changes
```
src/
  features/
    telemetry/
      SensorDataPage.tsx     # NEW — table UI + filters/sorting/pagination
      api.ts                 # (reuse) ensure it supports the same params
      transforms.ts          # (reuse) add small helpers if needed
  app/routes.tsx             # UPDATE — add route '/sensor-data'
  app/App.tsx (Sidebar)      # UPDATE — add nav item 'Sensor Data' if missing
```

### `src/features/telemetry/SensorDataPage.tsx` (sketch)
```tsx
import { useEffect, useMemo, useState } from 'react';
import { Alert, Button, Card, Label, Select, Spinner, Table, TextInput } from 'flowbite-react';
import { getTelemetry, TelemetrySample } from './api';

type SortKey = 'timestamp' | 'temperature' | 'humidity' | 'soilMoisture';
type SortDir = 'asc' | 'desc' | null;

export default function SensorDataPage() {
  const [items, setItems] = useState<TelemetrySample[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [form, setForm] = useState<{ from?: string; to?: string; limit: number; sensor?: string }>({
    limit: 100
  });
  const [sortKey, setSortKey] = useState<SortKey>('timestamp');
  const [sortDir, setSortDir] = useState<SortDir>('desc');
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(25);

  async function load() {
    setLoading(true);
    setError(null);
    try {
      const res = await getTelemetry(form);
      setItems(res.items || []);
      setPage(1);
    } catch (e: any) {
      setError(e.message || 'Failed to load telemetry');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { load(); /* eslint-disable-next-line react-hooks/exhaustive-deps */ }, []);

  function toggleSort(k: SortKey) {
    if (k !== sortKey) { setSortKey(k); setSortDir('asc'); return; }
    setSortDir(d => (d === 'asc' ? 'desc' : d === 'desc' ? null : 'asc'));
  }

  const sorted = useMemo(() => {
    if (!sortDir) return items;
    const m = [...items];
    m.sort((a, b) => {
      const va = (a as any)[sortKey];
      const vb = (b as any)[sortKey];
      if (sortKey === 'timestamp') {
        const ta = new Date(va).getTime();
        const tb = new Date(vb).getTime();
        return sortDir === 'asc' ? ta - tb : tb - ta;
      }
      return sortDir === 'asc' ? va - vb : vb - va;
    });
    return m;
  }, [items, sortKey, sortDir]);

  const start = (page - 1) * pageSize;
  const pageItems = sorted.slice(start, start + pageSize);
  const pageCount = Math.max(1, Math.ceil(sorted.length / pageSize));

  function reset() {
    setForm({ limit: 100 });
    setSortKey('timestamp');
    setSortDir('desc');
    setPage(1);
  }

  function exportCsv() {
    const rows = [
      ['timestamp','temperature','humidity','soilMoisture','sensor'],
      ...pageItems.map(r => [r.timestamp, r.temperature, r.humidity, r.soilMoisture, r.sensor ?? ''])
    ];
    const csv = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `telemetry_page_${page}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  if (loading) return <div className="min-h-[60vh] flex items-center justify-center"><Spinner size="xl" /></div>;
  if (error) return <div className="p-4"><Alert color="failure">{error}</Alert></div>;

  return (
    <div className="p-4 space-y-4">
      <Card>
        <div className="grid gap-3 md:grid-cols-6">
          <div className="md:col-span-2">
            <Label htmlFor="from" value="From (ISO)" />
            <TextInput id="from" value={form.from || ''} onChange={e => setForm({ ...form, from: e.target.value || undefined })} />
          </div>
          <div className="md:col-span-2">
            <Label htmlFor="to" value="To (ISO)" />
            <TextInput id="to" value={form.to || ''} onChange={e => setForm({ ...form, to: e.target.value || undefined })} />
          </div>
          <div>
            <Label htmlFor="limit" value="Limit" />
            <Select id="limit" value={form.limit} onChange={(e) => setForm({ ...form, limit: Number(e.target.value) })}>
              <option value={25}>25</option>
              <option value={50}>50</option>
              <option value={100}>100</option>
              <option value={200}>200</option>
            </Select>
          </div>
          <div>
            <Label htmlFor="sensor" value="Sensor (optional)" />
            <TextInput id="sensor" value={form.sensor || ''} onChange={e => setForm({ ...form, sensor: e.target.value || undefined })} />
          </div>
          <div className="md:col-span-6 flex gap-2">
            <Button onClick={load}>Apply</Button>
            <Button color="light" onClick={reset}>Reset</Button>
            <Button color="light" onClick={exportCsv}>Export CSV (page)</Button>
          </div>
        </div>
      </Card>

      <Card>
        <div className="overflow-x-auto">
          <Table>
            <Table.Head>
              <Table.HeadCell onClick={() => toggleSort('timestamp')} className="cursor-pointer select-none">
                Time {sortKey === 'timestamp' ? (sortDir === 'asc' ? '▲' : sortDir === 'desc' ? '▼' : '') : ''}
              </Table.HeadCell>
              <Table.HeadCell onClick={() => toggleSort('temperature')} className="cursor-pointer select-none">
                Temp (°C) {sortKey === 'temperature' ? (sortDir === 'asc' ? '▲' : sortDir === 'desc' ? '▼' : '') : ''}
              </Table.HeadCell>
              <Table.HeadCell onClick={() => toggleSort('humidity')} className="cursor-pointer select-none">
                Humidity (%) {sortKey === 'humidity' ? (sortDir === 'asc' ? '▲' : sortDir === 'desc' ? '▼' : '') : ''}
              </Table.HeadCell>
              <Table.HeadCell onClick={() => toggleSort('soilMoisture')} className="cursor-pointer select-none">
                Soil Moisture (%) {sortKey === 'soilMoisture' ? (sortDir === 'asc' ? '▲' : sortDir === 'desc' ? '▼' : '') : ''}
              </Table.HeadCell>
              <Table.HeadCell>Sensor</Table.HeadCell>
            </Table.Head>
            <Table.Body className="divide-y">
              {pageItems.map((r) => (
                <Table.Row key={`${r.timestamp}-${r.sensor ?? ''}`}>
                  <Table.Cell>{new Date(r.timestamp).toLocaleString()}</Table.Cell>
                  <Table.Cell>{r.temperature.toFixed(1)}</Table.Cell>
                  <Table.Cell>{r.humidity.toFixed(1)}</Table.Cell>
                  <Table.Cell>{r.soilMoisture.toFixed(1)}</Table.Cell>
                  <Table.Cell>{r.sensor ?? '—'}</Table.Cell>
                </Table.Row>
              ))}
            </Table.Body>
          </Table>
        </div>

        <div className="mt-4 flex items-center justify-between">
          <div className="text-sm text-gray-500">Page {page} / {pageCount}</div>
          <div className="flex items-center gap-2">
            <Label htmlFor="ps" value="Page size" />
            <Select id="ps" value={pageSize} onChange={e => { setPageSize(Number(e.target.value)); setPage(1); }}>
              <option value={25}>25</option>
              <option value={50}>50</option>
            </Select>
            <Button color="light" disabled={page <= 1} onClick={() => setPage(p => Math.max(1, p - 1))}>Prev</Button>
            <Button color="light" disabled={page >= pageCount} onClick={() => setPage(p => Math.min(pageCount, p + 1))}>Next</Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
```

---

## Acceptance
- New route `/sensor-data` renders a table with telemetry items and supports:
  - Filters (from/to/limit/sensor) and **Apply**/**Reset**.
  - Client-side sorting by clicking column headers (timestamp/temp/humidity/soil).
  - Client-side pagination with page size select (25/50).
  - Optional CSV export of the **current page**.
- Proper states: Spinner for loading; failure Alert on errors; Info Alert for empty results.
- Layout is responsive and avoids horizontal scroll on sm/md/lg.

---

## Notes for agents
- Keep changes limited to telemetry feature + router/nav.
- Do not introduce new libraries. Use Flowbite components + Tailwind utilities.
- Reuse the existing Axios client and envelope checks.
