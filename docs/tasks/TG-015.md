# TG-015 — Alerts generation (backend): derive alerts from thresholds & telemetry

**Goal**  
Add a backend alerting service that derives **active alerts** from the latest telemetry data, using **per-user thresholds** from `/api/notifications`. Provide endpoints to read active alerts and recent history; keep it simple and demo-friendly in mock mode.

> Stack: Fastify + TypeScript + Zod + Pino. No new runtime deps required.

---

## What we’ll detect (v1)
- **SOIL_MOISTURE_LOW** — if latest soil moisture `< prefs.thresholds.soilMoistureLow`.
- **TEMP_HIGH** — if latest temperature `> prefs.thresholds.tempHigh`.
- **SENSOR_STALE** — if no telemetry sample in the last **X minutes** (default 10m).

Each alert has: `id`, `type`, `severity`, `message`, `startedAt`, `resolvedAt?`, `sensor?`, `value?`, `threshold?`.

**Severity**: `"warn"` for threshold crossings; `"critical"` for extremely stale data (e.g., >60m).

**Hysteresis & dedup (simple v1):**
- Threshold alerts close when the metric returns within a **2% / 1°C** buffer.
- We keep alerts **open** while the condition persists; we do **not** create duplicates on every run.

---

## API
- `GET /api/alerts` → `{ ok: true, data: { items: Alert[], total: number } }` — **active** alerts only.
- `GET /api/alerts/history?limit=100` → recent `Alert[]` (active + resolved), newest first.
- `POST /api/alerts/:id/ack` → mark alert as acknowledged (optional v1; no effect on logic).

All routes are **per-user** (respect auth mock/firebase) and must not leak data between users.

---

## Types (Zod/TS)
```ts
// src/lib/schemas.ts
export const AlertType = z.enum(['SOIL_MOISTURE_LOW','TEMP_HIGH','SENSOR_STALE']);
export type AlertType = z.infer<typeof AlertType>;

export const AlertSeverity = z.enum(['info','warn','critical']);
export type AlertSeverity = z.infer<typeof AlertSeverity>;

export const AlertSchema = z.object({
  id: z.string(),
  type: AlertType,
  severity: AlertSeverity,
  message: z.string(),
  startedAt: z.string(),       // ISO
  resolvedAt: z.string().optional(),
  acknowledged: z.boolean().default(false),
  sensor: z.string().optional(),
  value: z.number().optional(),
  threshold: z.number().optional(),
});
export type Alert = z.infer<typeof AlertSchema>;
```

---

## Implementation

### 1) Service
Add `src/services/alerts.ts`:

```ts
import { Alert } from '../lib/schemas';
import { getUserPrefs } from './prefs';               // new tiny helper to read NotificationPrefs for uid
import { getLatestTelemetry } from './telemetry';     // new tiny helper to read latest sample(s) per uid
import { nanoid } from 'nanoid';                      // optional; if avoiding deps, make a simple id

type Store = {
  active: Map<string, Alert>;  // id -> Alert
  history: Alert[];            // append-only (cap to N)
};
const stores = new Map<string, Store>();              // uid -> Store

const HYSTERESIS = { soilPct: 2, tempC: 1 };
const STALE_MIN = 10;    // warn if older than 10 min
const STALE_CRIT = 60;   // critical if older than 60 min
const HISTORY_CAP = 500;

function getStore(uid: string): Store {
  let s = stores.get(uid);
  if (!s) { s = { active: new Map(), history: [] }; stores.set(uid, s); }
  return s;
}

export async function recomputeAlerts(uid: string, now = new Date()) {
  const store = getStore(uid);
  const prefs = await getUserPrefs(uid);             // { thresholds: { soilMoistureLow, tempHigh }, ... }
  const latest = await getLatestTelemetry(uid);      // most recent sample (or per sensor later)

  if (!latest) return;

  const msAgo = (now.getTime() - new Date(latest.timestamp).getTime()) / 60000;
  // SENSOR_STALE
  if (msAgo >= STALE_MIN) {
    upsert(uid, {
      type: 'SENSOR_STALE',
      severity: msAgo >= STALE_CRIT ? 'critical' : 'warn',
      message: msAgo >= STALE_CRIT ? 'Sensor data is stale for over an hour' : 'Sensor data is stale',
      startedAt: new Date(now.getTime() - msAgo * 60000).toISOString(),
    });
  } else {
    closeIf(uid, 'SENSOR_STALE', () => msAgo < STALE_MIN);
  }

  // SOIL_MOISTURE_LOW
  if (latest.soilMoisture < prefs.thresholds.soilMoistureLow) {
    upsert(uid, {
      type: 'SOIL_MOISTURE_LOW',
      severity: 'warn',
      message: `Soil moisture low: ${latest.soilMoisture}% < ${prefs.thresholds.soilMoistureLow}%`,
      startedAt: latest.timestamp,
      value: latest.soilMoisture,
      threshold: prefs.thresholds.soilMoistureLow,
    });
  } else {
    closeIf(uid, 'SOIL_MOISTURE_LOW', () => latest.soilMoisture >= (prefs.thresholds.soilMoistureLow + HYSTERESIS.soilPct));
  }

  // TEMP_HIGH
  if (latest.temperature > prefs.thresholds.tempHigh) {
    upsert(uid, {
      type: 'TEMP_HIGH',
      severity: 'warn',
      message: `Temperature high: ${latest.temperature}°C > ${prefs.thresholds.tempHigh}°C`,
      startedAt: latest.timestamp,
      value: latest.temperature,
      threshold: prefs.thresholds.tempHigh,
    });
  } else {
    closeIf(uid, 'TEMP_HIGH', () => latest.temperature <= (prefs.thresholds.tempHigh - HYSTERESIS.tempC));
  }
}

function upsert(uid: string, partial: Omit<Alert,'id'|'acknowledged'|'resolvedAt'>) {
  const store = getStore(uid);
  const key = partial.type; // one active per type in v1
  const existing = Array.from(store.active.values()).find(a => a.type === partial.type);
  if (existing) return; // keep existing open
  const id = `${partial.type}-${Date.now()}`;
  const alert: Alert = { id, acknowledged: false, resolvedAt: undefined, ...partial };
  store.active.set(id, alert);
}

function closeIf(uid: string, type: Alert['type'], predicate: () => boolean) {
  const store = getStore(uid);
  const entry = Array.from(store.active.values()).find(a => a.type === type);
  if (entry && predicate()) {
    store.active.delete(entry.id);
    store.history.unshift({ ...entry, resolvedAt: new Date().toISOString() });
    if (store.history.length > HISTORY_CAP) store.history.length = HISTORY_CAP;
  }
}

export function getActive(uid: string): Alert[] {
  return Array.from(getStore(uid).active.values());
}
export function getHistory(uid: string, limit = 100): Alert[] {
  return getStore(uid).history.slice(0, limit);
}
export function ack(uid: string, id: string) {
  const store = getStore(uid);
  const a = store.active.get(id);
  if (a) { a.acknowledged = true; }
}
```

> **Note:** For v1, `getUserPrefs` can read from the same mock in-memory prefs used by `/api/notifications`.  
> `getLatestTelemetry` can read the last item from the mock telemetry store for the user.

### 2) Routes
Add `src/routes/alerts.ts`:

```ts
import { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { getActive, getHistory, ack, recomputeAlerts } from '../services/alerts';
import { Envelope } from '../lib/respond';

export default async function routes(app: FastifyInstance) {
  app.get('/api/alerts', { preHandler: app.auth }, async (req, reply) => {
    const uid = req.user.uid;
    await recomputeAlerts(uid);
    const items = getActive(uid);
    const data = { items, total: items.length };
    return reply.send(Envelope.ok(data));
  });

  app.get('/api/alerts/history', { preHandler: app.auth }, async (req, reply) => {
    const uid = req.user.uid;
    const q = z.object({ limit: z.coerce.number().min(1).max(500).default(100) }).parse(req.query);
    const items = getHistory(uid, q.limit);
    return reply.send(Envelope.ok({ items, total: items.length }));
  });

  app.post('/api/alerts/:id/ack', { preHandler: app.auth }, async (req, reply) => {
    const uid = req.user.uid;
    const params = z.object({ id: z.string() }).parse(req.params);
    ack(uid, params.id);
    return reply.send(Envelope.ok({ id: params.id }));
  });
}
```

Register in `src/app.ts` **after** auth plugin:
```ts
import alerts from './routes/alerts';
app.register(alerts);
```

### 3) Periodic recompute (optional for demo)
In `src/app.ts` after routes:
```ts
const TICK_MS = 30_000;
setInterval(() => {
  // in mock mode, you can recompute for a small set of demo uids, e.g. ['demo']
  recomputeAlerts('demo').catch(err => app.log.error({ err }, 'alert recompute failed'));
}, TICK_MS);
```

---

## Acceptance
- `GET /api/alerts` returns computed **active** alerts for the current user based on latest telemetry + prefs.
- `GET /api/alerts/history?limit=100` returns resolved/active alerts history (newest first, capped).
- `POST /api/alerts/:id/ack` marks an open alert as acknowledged; subsequent reads reflect the flag.
- Threshold alerts open/close correctly with the stated hysteresis; **SENSOR_STALE** opens if last sample older than 10 min, escalates to `critical` after 60 min.
- No cross-user data leakage; all stores and reads are scoped by `uid` (mock or firebase).

---

## Notes & Next
- Next tasks could send notifications (email/push/SSE/WebSocket) when alerts change, or compute more alert types (humidity low/high, light-hours deviation), or persist alerts in SQLite via Prisma.
